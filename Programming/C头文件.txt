1、从C源文件到可执行文件，需要经过预编译、编译、汇编和链接四个主要生产工序，每个生产工序应该对应各自的软件工具，如预编译器、C/CPP编译器、汇编器、链接器。每一个C/CPP源文件是一个独立的单元或模块，每个编译单元经编译后会生成一个.o文件。一般而言，每个C++/C程序通常由“头文件”和“定义文件”组成。头文件作为一种包含功能函数、数据接口声明的载体文件，主要用于保存程序的声明，而定义文件用于保存程序的实现。

2、对于预编译工具来说，其输入是 *.c, *.cpp, 输出是 *.i 文件，并通过 ‘#’开头的预编译指令控制预编译器的行为。头文件也是预编译工具的输入参数，但不能在预编译命令后面直接列出，必须放置在预编译工具能搜索到的include文件夹中或者当前目录中。

3、头文件通常但不必然命名为*.h。通过#include预编译指令将其引入C/CPP文件中，如果没有#include指令，预编译器无法识别头文件？

4、头文件的作用通常是将本单元模块（C/CPP源文件）中可供其它单元使用的宏、变量或函数声明，其它模块通过#include指令将其包含，以便使用这些公开的接口。本单元模块不公开的接口，应用‘static’关键字显式表明该接口是不公开的，仅在本单元中使用，因而不应在头文件中列出。

5、通常情况下，头文件example.h的内容是：公开的全局变量及函数声明，公开的宏定义等；在本单元example.c中对公开的全局变量及函数进行定义。如果本单元不对外公开接口，那么头文件不是必须的。在本单元example.c中加入#include "example.h"语句后,可先使用公开接口，然后在文件末尾再定义；如果本单元example.c中不加入#include "example.h"语句,则接口应先定义后使用。

6、头文件中公开的全局变量及函数应使用‘extern’关键字显式声明！。以便其它单元引用时能准确的识别。‘extern’的意思是‘本文件（.c/.cpp/.h）外部定义的’。特别是对于本单元公开的全局变量，如果该变量没有‘extern’关键字修饰，那么本单元头文件被其它单元引用时，会被编译器误认为在其它单元中又定义了一个同名变量，从而形成重复定义错误。全局函数的声明默认具备‘extern’关键字修饰，因此全局函数申明可以不加‘extern’关键字。但在公开的接口均加上‘extern’关键字显得整齐划一，含义清晰。此外，本单元未公开的全局变量也能被其它单元引用，显然此种方式只能通过“内部小道消息”的方式获得，但这样对于大型程序来说是不健康的行为。如：本单元有一个全局变量A，但其未经过头文件公开，另一个单元要使用时，可以使用extern A语句声明。

7、为了提高编译速度，头文件中应仅仅包含需要引用的其它头文件。

8、头文件中的‘#pragma once 或 #ifndef __symbol …… #endif’预编译指令，其作用是避免本编译单元重复包含此头文件；对于不同的编译单元上述预编译指令不会相互影响，即是说编译单元A和编译单元B均包含了同一个头文件，那么该头文件都将在两个编译单元中展开。

9、据网络，宏定义是没有先后次序的，猜想预编译器采用递归的方式展开宏，直到所有宏被替换为规定的语言关键字。如果头文件间嵌套引用（在a.h中#include b.h，在b.h中#include a.h），将导致预编译器循环展开而发生错误，因此头文件间不能嵌套引用。

10、Google风格遵循的是从一般到特殊的原则。首先包含本文件的头文件，其次按照稳定度从高到底依次包含：C标准库、C++标准库、其它库的头文件，本工程其他头文件。操作系统级别的头文件，视其依赖的库放置，比如Linux操作系统提供的SDK，不能归入C标准库，因此包含顺序应该是：本文件的头文件，OS SDK .h , C标准库、C++标准库、其它库的头文件、本工程的其他头文件。
	xxx.h
	C 系统文件
	C++ 系统文件
	其他库的 .h 文件
	本项目内 .h 文件


C/C++ 预编译工具
cpp：C/C++ 编译器自带的预处理器，它会处理源文件中的预处理指令，如 #include、#define、#ifdef 等。它将处理后的代码输出给编译器进行后续的编译工作。在使用 GCC 或 Clang 等编译器编译 C/C++ 代码时，会自动调用 cpp 进行预处理。
GNU M4：是一个通用的宏处理器，它可以用于处理 C/C++ 等多种语言的源文件。M4 提供了丰富的宏定义和替换功能，允许用户定义复杂的文本替换规则，常用于生成代码模板、配置文件等。

通用宏处理器
CM4
简介：CM4 是一款轻量级的宏处理器，语法和 GNU M4 较为相似。它的设计目标是提供简洁、高效的宏处理功能，能处理各类文本文件。
特点：易于上手，运行速度快，适合处理小型项目或对性能要求较高的场景。在一些简单的脚本生成或文本替换任务中表现出色。

Tcl 宏处理器
简介：Tcl（Tool Command Language）本身是一种脚本语言，同时也具备强大的宏处理能力。它可以利用自身的变量、过程等特性实现宏替换和文本处理。
特点：具有动态性和灵活性，支持交互式编程。Tcl 有丰富的库和工具，可用于开发复杂的宏处理程序，在自动化测试、系统管理等领域应用广泛。

特定领域宏处理器
TeX 和 LaTeX 宏处理器
简介：TeX 是一种用于排版的标记语言，其自带强大的宏处理功能。LaTeX 则是基于 TeX 的高级排版系统，进一步扩展了宏的使用。在学术论文、书籍等文档排版中，TeX 和 LaTeX 允许用户定义自己的宏来简化复杂的排版格式。
特点：专门针对文档排版设计，能够生成高质量的印刷品。宏可以控制字体、段落格式、图表位置等各种排版元素，使得文档排版更加规范和高效。

汇编宏处理器
简介：不同的汇编器（如 MASM 用于 x86 汇编，GAS 是 GNU 汇编器）都有自己的宏处理功能。汇编宏处理器允许程序员定义代码片段的缩写形式，提高代码的可读性和可维护性。
特点：紧密结合汇编语言的特性，可实现代码复用和简化编程。例如，在编写复杂的汇编程序时，可以使用宏来封装常用的指令序列，减少重复代码。

C 预处理器（cpp）
简介：C 预处理器是 C 和 C++ 编译器的一部分，用于处理源代码中的预处理指令，如 #define、#include 等。它可以进行宏定义、文件包含、条件编译等操作。
特点：与 C/C++ 语言紧密集成，为程序员提供了强大的代码生成和条件编译能力。例如，通过宏定义可以实现简单的函数或常量替换，通过条件编译可以根据不同的编译选项生成不同的代码。

C 预处理器（C Preprocessor，简称 cpp）是 C 和 C++ 编译过程中的第一个阶段，它会在正式编译之前对源代码进行一系列文本替换和处理操作。以下是关于 C 预处理器的详细使用介绍：
1. 基本概念
作用：C 预处理器主要负责处理以 # 开头的预处理指令，这些指令可以控制代码的编译过程，如包含头文件、定义宏、进行条件编译等。
执行时机：在编译器进行语法分析和代码生成之前执行，它会将处理后的代码传递给编译器进行后续处理。
2. 常用预处理指令
2.1 #define：定义宏
语法：
c
#define 宏名 替换文本
示例：
c
#define PI 3.14159
#define MAX(a, b) ((a) > (b) ? (a) : (b))

#include <stdio.h>

int main() {
    double radius = 5.0;
    double area = PI * radius * radius;
    printf("Area of the circle: %f\n", area);

    int x = 10, y = 20;
    int max_val = MAX(x, y);
    printf("Max value: %d\n", max_val);

    return 0;
}
解释：
第一个 #define 定义了一个常量宏 PI，在后续代码中遇到 PI 会被替换为 3.14159。
第二个 #define 定义了一个带参数的宏 MAX，用于比较两个数的大小并返回较大值。
2.2 #include：包含头文件
语法：
c
#include <文件名>  // 从系统指定的标准库目录中查找头文件
#include "文件名"  // 先从当前源文件所在目录查找，若找不到再从系统标准库目录查找
示例：
c
#include <stdio.h>  // 包含标准输入输出库的头文件
#include "myheader.h"  // 包含自定义头文件

int main() {
    printf("Hello, World!\n");
    return 0;
}
2.3 #ifdef、#ifndef、#endif：条件编译
语法：
c
#ifdef 宏名
    // 如果宏已定义，则编译这里的代码
#else
    // 否则编译这里的代码
#endif

#ifndef 宏名
    // 如果宏未定义，则编译这里的代码
#else
    // 否则编译这里的代码
#endif
示例：
c
#define DEBUG

#ifdef DEBUG
    #define PRINT_DEBUG_INFO printf
#else
    #define PRINT_DEBUG_INFO(...) ((void)0)
#endif

#include <stdio.h>

int main() {
    PRINT_DEBUG_INFO("This is a debug message.\n");
    return 0;
}
解释：
当 DEBUG 宏被定义时，PRINT_DEBUG_INFO 会被替换为 printf，从而输出调试信息。
当 DEBUG 宏未定义时，PRINT_DEBUG_INFO 会被替换为一个空操作，不会输出调试信息。
2.4 #undef：取消宏定义
语法：
c
#undef 宏名
示例：
c
#define MAX 100

// 使用 MAX 宏
int value = MAX;

#undef MAX

// 此时 MAX 宏已被取消定义，不能再使用
// int new_value = MAX;  // 这行代码会报错

#include <stdio.h>

int main() {
    printf("Value: %d\n", value);
    return 0;
}
3. 预定义宏
C 预处理器还提供了一些预定义宏，这些宏在编译时自动定义，可用于获取编译环境的相关信息。
__FILE__：表示当前源文件的文件名。
__LINE__：表示当前代码所在的行号。
__DATE__：表示编译日期。
__TIME__：表示编译时间。
示例：
c
#include <stdio.h>

int main() {
    printf("File: %s\n", __FILE__);
    printf("Line: %d\n", __LINE__);
    printf("Date: %s\n", __DATE__);
    printf("Time: %s\n", __TIME__);
    return 0;
}
4. 预处理器运算符
#：字符串化运算符，将宏参数转换为字符串常量。
c
#define STRINGIFY(x) #x

#include <stdio.h>

int main() {
    printf("String: %s\n", STRINGIFY(Hello));
    return 0;
}
##：标记连接运算符，将两个标记连接成一个新的标记。
c
#define CONCAT(x, y) x##y

#include <stdio.h>

int main() {
    int num12 = 123;
    printf("Value: %d\n", CONCAT(num, 12));
    return 0;
}
5. 编译时使用预处理器
在使用 GCC 等编译器编译 C 代码时，预处理器会自动执行。也可以单独调用预处理器进行处理：
bash
gcc -E source.c -o source.i
该命令会对 source.c 文件进行预处理，并将处理后的结果输出到 source.i 文件中。